# Постановка задачи

## Цель задания

Задание предназначено для закрепления знаний об Applicative, Traverse и функциональных паттернов обработки ошибок.

## Контекст

Мы делаем сервис, который будет вызываться мобильным приложением банка для работы с банковскими картами.

По требованиям безопасности реальная обработка персональных данных и данных банковских карт, включая операции по ним, должны осуществляться в специальном
защищенном контуре, который недоступен извне, по этой причине наш сервис выполняет роль умного гейтвея 
с минимальным количеством бизнес-логики.

Также по требованиям безопасности важно, чтобы реальные карточные данные не хранились нигде за пределами
защищенного контура, а также не передавались наружу без специального запроса, 
поэтому данные карт нужно маскировать специальным образом для отображения пользователю.

## Постановка задачи

Реализуйте метод `getOperationsStatistics` [CardService](./service/CardService.scala) для получения статистики поступлений и расходов по картам и основному счету.

Независимые вычисления должны быть закодированы так, чтобы была возможность их выполнить в произвольном порядке.

Принцип маскирования данных карты:
* номер `XXXX-XXXX-XXXX-XXXX` должен быть заменен на `XXXX-****-****-*XXX`
* cvv должен быть заменен на `***`
* дата в формате `MM/YY` должна быть заменена на `**\**`

Для надежности работы гейтвея нужно использовать следующие паттерны отказоустойчивости:
1. [Retry](./resilience/Retry.scala), который нужно также реализовать: это ограниченное количество повторов с задержкой операций, которые завершились ошибкой, которая может пройти сама собой (сетевой сбой, временная недоступность и т.д.). Для задержки используйте [Timer](./utils/Timer.scala) (его реализовывать не нужно).
2. Null Object для списочных данных. Если в результате выполнения запроса все повторы упали с ошибкой или повтор не нужен, то вместо ошибки нужно вернуть пустой объект, то есть `List.empty`.
3. [Fallback Cache](./resilience/FallbackCache.scala) для данных карт, который нужно имплементировать как обертку вокруг [Cache](./utils/Cache.scala) (его реализовывать не нужно). Фоллбэк-кэш все удачные результаты запросов записывает в кэш, чтобы при получении ошибки (нельзя повторить или все повторы неудачны) взять последний успешный результат из кэша.

Для тайпклассов Retry и FallbackCache можно реализовать синтаксис для более удобного использования в коде.

Для реализации маскирования можно воспользоваться тайпклассом [Masking](./masking/Masking.scala).

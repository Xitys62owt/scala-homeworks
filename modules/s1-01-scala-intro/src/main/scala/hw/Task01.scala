package hw

/**
  * Все задачи необходимо реализовать через хвостовую рекурсию.
  */

/**
  * 1. Реализуйте метод, который переворачивает неотрицательные числа
  *
  *  swap(327849) = 948723
  *  swap(1) = 1
  *  swap(100) = 1
  *  swap(42) = swap(24)
  */
def swap(x: Long, acc: Long = 0): Long =
  if (x <= 0) acc else swap(x / 10, 10 * acc + x % 10)

/**
  * 2. Реализуйте метод, возвращающий n-ое число последовательности:
  *
  *  1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, ....
  *  (каждое число повторяется ровно столько раз, чем равно это самое число)
  *
  *  selfRepeat(0) = 1
  *  selfRepeat(1) = 2
  *  selfRepeat(2) = 2
  *  selfRepeat(3) = 3
  *  selfRepeat(10) = 5
  *  selfRepeat(42) = 9
  */
def selfRepeat(n: Int, acc: Int = 1): Int =
  if (n < 1) (if (n == 0) acc else (acc - 1)) else selfRepeat(n - acc, acc + 1)

/**
  * 3. Фибоначчи, делящиеся на k
  *
  * Рассмотрим последовательность Фибоначчи:
  *
  *  0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711 ...
  *
  * Давайте рассмотрим последовательность, которая берет только числа, делящиеся на (k > 1):
  *    (k = 2): 0, 2, 8, 34, 144, 610, 2584, 10946, 46368, 196418, 832040, 3524578, 14930352, 63245986, 267914296, 1134903170, 4807526976 ...
  *    (k = 3): 0, 3, 21, 144, 987, 6765, 46368, 317811, 2178309, 14930352, 102334155, 701408733, 4807526976, 32951280099, 225851433717, ...
  *    (k = 4): 0, 8, 144, 2584, 46368, 832040, 14930352, 267914296, 4807526976, 86267571272, 1548008755920, ...
  *    ...
  *
  * Необходимо реализовать метод, который берет на вход (k > 1, n >= 0) и возвращает n-ый эелемент последовательности для делителя k.
  *
  *    fibDiv(2, 0) = 0
  *    fibDiv(2, 1) = 2
  *    fibDiv(2, 2) = 8
  *
  *    fibDiv(3, 0) = 0
  *    fibDiv(3, 1) = 2
  *    fibDiv(3, 2) = 21
  *
  *    fibDiv(10, 2) = 832040
  */
def fibDiv(k: Int, n: Int, acc1: Long = 0, acc2: Long = 1): Long =
  if (n <= -1) acc2 - acc1
  else if (acc1 % k == 0)
    fibDiv(k, n - 1, acc2, acc1 + acc2)
  else fibDiv(k, n, acc2, acc1 + acc2)
// я не придумал как не делать лишний подсчет (чтобы возвращать просто acc1, а не acc2-acc1)
// без использования временных переменных типа val

/**
  * 4. (* опционально) Максимум в дереве
  *
  * Задана структура данных --- (полное) бинарное дерево, в узлах и листьях которого значения типа Int
  */
enum Tree:
  def value: Int

  case Node(value: Int, left: Tree, right: Tree)
  case Leaf(value: Int)

import Tree.*

/**
  * 4.1 Реализовать метод maxT, который находит максимум в дереве:
  *
  * Для такого дерева:
  *
  *            10
  *          /     \
  *         1       -3
  *      /     \
  *     13      42
  *           /   \
  *         32     14
  *        /   \
  *       41    0
  *
  * Результат метода должен быть 42.
  *
  *
  *
  */
def maxT(tree: Tree): Int =
  tree match
    case Node(value, left, right) => (value max maxT(left) max maxT(right))
    case Leaf(value)              => value

/**
  * 4.2
  *
  * Реализовать метод mapT, который применяет функцию f: Int => Int ко
  * всем значениям в дереве
  *
  * Для такого дерева и функции (_ * 2):
  *
  *            10
  *          /     \
  *         1       -3
  *      /     \
  *     13      42
  *           /   \
  *         32     14
  *        /   \
  *       41    0
  *
  * Результат должен быть:
  *
  *
  *             20
  *          /     \
  *         2       -6
  *      /     \
  *     26      84
  *           /   \
  *         64     28
  *        /   \
  *       82    0
  *
  */
def mapT(t: Tree, f: Int => Int): Tree =
  t match
    case Node(value, left, right) => Node(f(value), mapT(left, f), mapT(right, f))
    case Leaf(value)              => Leaf(f(value))
